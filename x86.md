##prerequisites:
 * History: protected mode，1982 80286 first introduced.
 * hex,dec,bin:
	 * sizeof(MBR) = 512B = 2^9B = 0x200, 
	 * highest_addr(MBR) = 512 - 1 = 2^9 - 1 = 0x200 - 1 = 0x1ff
 * signed number:
	 * true form: mathematical notation.  
	   e.g. 8bits signed integer (first bit represents sign):  
	   (`10000001b (true code) = 0x81 (true code) = -1 (true form)`)
	 * machine code: true code (原), 1's complement (反), 2's complement (补)
		 * definition:
			 * integer x, word length n.

	
		 			truecode(x) = x, if 0<=x<=2^(n-1)-1
		 			            = 2^(n-1)+abs(x), if -(2^(n-1)-1)<=x<=0
		 			1complement(x) = x, if 0<=x<=2^(n-1)-1
		 			               = 2^(n-1)+2^(n-1)-1-abs(x) (*)
		 			               = 2^n-1+x (simplified), if -(2^(n-1)-1)<=x<=0
		 			2complement(x) = x, if 0<=x<=2^(n-1)-1
		 			               = 2^n+x
		 			annotation: (*) first 2^(n-1) means to assign 1 to the sign bit, 2^(n-1)-1-abs(x) equals value  bits inversed.
		 * domain and range:

				truecode		truecode		1com^-1(x)	2com^-1(x)
				2^(n-1)			1000 0000		-127		-128
				2^(n-1) + 1		1000 0001		-126		-127
				...				...				...			...
				2^n-1			1111 1111		-0			-1
		 * arith: 
			 * see "math behind"
		 * math behind:
			 * congruential (同余) (best metaphor, clock),

					assume a,b>0, we have.
					a-b = (1com(a)+1com(-b)+1) mod 2^(n-1), if a>=b
				 	    = 1com^-1(1com(a)+1com(-b)), if a<b
				 	a-b = (2com(a)+2com(-b)) mod 2^(n-1), if a>=b
				 	    = 2com^-1(2com(a)+2com(-b)) mod 2^(n-1), if a<b
				 	    	 
 * asm:
	 * 2 flavors: intel, at&t.
			
			diff
				1. two oprand cmd: intel dst, src;
				2. immediate value: intel require no '$'
				3. memory addressing: intel uses '[]'
	 * gcc x86 (uses at&t) cheat sheet, see: [https://www.cs.uaf.edu/2005/fall/cs301/support/x86/index.html]()
	 * nasm (uses intel)
	 * rules:
	 
			1. forbid 'segment reg <- immediate value'
			2. allow only 'out dx, al', 'in al, dx'
			3. forbid 'push immediate value'

 * 8086 memory segmentation:
	 * register having 16bits , determines segement size (no more than 2^16=64k)
	 * complication: x86 has 20bit address bus, meaning CPU can address up to 1MB = 16*64k memory).
	 * design against complication:

			logic address `DS:SI`, 
			physical address:`DS<<16+SI`
 * boot sequence:
	 * `power --> BIST --> BIOS --> MBR --> bootloader --> os`
	 * standard:  
	   8086 BIOS load MBR into `0x0000:0x7c00` or `0x07c0:0x0000` (same physical address `0x7c00`).  
	   best practice is to use pseudo asm: `org 0x7c00` (org stands for origin), to tell nasm to address on the basis of origin.  

 * hdd physical organizations: ([http://sabercomlogica.com/en/]())
	 * HDD addressing: 
		 * physical level--magnetic field, inversion/non-inversion
		 * machine level--CHS (**C**ylinder **H**ead **S**ector):  
		   platter(面),  track(道),  sector(区)  
		 * hardware level--LBA (**L**ogic **B**lock **A**ddressing):  
		   implemented by logic board of an HDD
		 * OS level--Files
		 * general view:

  
				       +--+         +-----------+         +---+
				File-->|OS|-->LBA-->|logic board|-->CHS-->|HDD|-->mag inv
				       +--+         +-----------+         +---+
	 * if hdd is the boot device, on power up, BIOS  will try to read platter0,track0,sector1 (MBR).

 * video card
	 * video card tells monitor what to display:  
	   `periodically, draw bits in vram, translate into pixels`
	   `two display modes, translate differently`
	 * Graphics mode:
		 * map a number of bits to a pixel
		 * real color:
			 * 3Bytes = 24bits represents 1pixel, that's 2^24 colors.
	 * Text mode:
		 * map a number of bits to a character, then let character generators handles pixels.
		 * 8086 char buffer starts at 0xB800
		 * 256 color (8bits) ascii (8bits) format:

				16bit data type:
				+-+-+-+-+-+-+-+-+ +--------+
				|K|R|G|B|I|R|G|B| | ascii  |
				+-+-+-+-+-+-+-+-+ +--------+
				;background RGB, forground RGB
				;K stands for blinK, I stands for brIghtness
				;e.g. static nohl white on black 'H':
				;     0x076C

##real mode:
 * 8086 memory mapping:
	 * can address up to 1MB = 16 * 64KB


	 		+-------------+
	 		|F0000 ~ FFFFF| ==> (1*64KB) BIOS-ROM
	 		+-------------+ 
	 		|E0000 ~ EFFFF| \
	 		+-------------+  |
	 		|    .....    |   > (5*64KB) Expansion Device RAM
	 		+-------------+  |  (Video Display RAM B0000~BFFFF)
	 		|A0000 ~ AFFFF| /   (char buffer B8000~BFFFF)
	 		+-------------+
	 		|90000 ~ 9FFFF| \
	 		+-------------+  |
	 		|    .....    |   > (10*64KB) Main Memory
	 		+-------------+  |
	 		|00000 ~ 0FFFF| /
	 		+-------------+

 * bulk transfer(`movsw`, `movsb`):
	 * transfer unit: `movsw` moves words, `movesb` moves bytes
	 * args:  
		 * src addr: `DS:SI`,
		 * dst addr: `ES:DI`,
		 * count: `cx`,
		 * direction: `FLAGS 10th bit`, `DF` (Direction Flag), `cld` / `std` to clear / set `DF`

 * loop:
	 * `loop label` <==> `sub cx, 1`, `jcxz label` (`cx--` first!)
	         
 * arith:
	 * div: 
		 * type 1: 16bit/8bit == 8bit ... 8bit  
				 dividend stored in ax, 8 bits (reg or mem) as divisor, quotients stored in lower half of , remainder 

					+--+--+     +--+    +--+     +--+
					|ah|al| / | |8b| == |al| ... |ah|
					+--+--+     +--+    +--+     +--+
		 * type 2: 32bit/16bit = 16bit ... 16bit

					+----+----+   +----+    +----+     +----+
					| dx | ax | / |16bt| == | ax | ... | dx |
					+----+----+   +----+    +----+     +----+
 * little-endian:  

				;intel grammar.
		 		number db 0x34,0x12
		 		mov ax,number
		 		;ax is actually 0x1234 instead of 0x3412.
		 		; what happened after 'mov ax,number': 
		 		;    in ram:         |    in ax:
		 		;    +----+  /\      |    +----+----+ 
		 		;    |0x12|  ||      |    |0x12|0x34|
		 		;    +----+  ||      |    +----+----+
		 		;    |0x34|  ||      |      ah   al
		 		;    +----+          |
		 		

 * jmp:

	 * near:
			
			;dot list file (.lst)
	 		0x7C00: jmp near 0x7C11
	 		;machine code (hex): E9 11 00
	 		;3Bytes instruction
	 		;operand is a 2B delta (dst - src).

 *  addressing:
	 		
	 		;intel grammar.
	 		
	 		;direct addressing:
	 		mov ax, [0x0010], 
	 		;physical address: DS<<4+0x0010
	 		
	 		;indirect addressing, base plus offset:
	 		mov ax, [bx+si] (or mov ax, [bx+di])
	 		;physical address ds<<4+bx+si (or dx<<4+bx+di)
	 		mov ax, [bp+si] (or di)
	 		;physical address ss<<4+bp+si (or di)

* section:
			
			;intel grammar.
			SECTION code_0 align=16 vstart=0
			mov ax, 0
			SECTION data_0 align=16 vstart=0
			db 0x11
			SECTION data_1 align=16 vstart=0
			db 0x22
			
			;'SECTION': pseudo asm, defines a section,
			
			;'align' means to start the section at address  addr \ 
			where 16 (or 32) | addr. \
			e.g. data_0, data_1 machine code:
			;0x0000: 1100 0000 0000 0000 0000 0000 0000 0000
			;0x0010: 2200 0000 0000 0000 0000 0000 0000 0000
			
			;'vstart': pseudo asm, tells the assembler to calc relative address based on section.

* io：
	* 2 techniques: bus and ich
		* different IOs, share same bus, modern PC uses two sets of bus: one for memory and one for IO (to reduces CPU overhead)
		* ich (IO controller hub) a.k.a. south bridge, acts as a hub, deals with IO conflicts (because they share the same bus).
	* IO access in x86 architecture:
		* stand alone coding (not unified coding). i.e. each IO device has its own address space (ports).
		* 8086 can address at most 2^16=64K=65535 ports, and each port stores an octet (8bits or 2nibbles).
		* x86 uses in/out cmd instead of mov to access IO ports.

* hard drive:
	* controller board: LBA28
	* 
* video card:
	* hardware standard: VGA
* loader: